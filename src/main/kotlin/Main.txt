package com.magnariuk

import com.github.ajalt.clikt.completion.completionOption
import com.github.ajalt.clikt.core.*
import com.github.ajalt.clikt.parameters.arguments.argument
import com.github.ajalt.clikt.parameters.arguments.multiple
import com.github.ajalt.clikt.parameters.options.associate
import com.github.ajalt.clikt.parameters.options.convert
import com.github.ajalt.clikt.parameters.options.flag
import com.github.ajalt.clikt.parameters.options.option
import com.github.ajalt.clikt.parameters.options.required
import com.github.ajalt.clikt.parameters.types.choice
import com.github.ajalt.clikt.parameters.types.int
import com.magnariuk.data.configs.INSTANCE_CONFIG
import com.magnariuk.util.configs.editGlobalConfig
import com.magnariuk.util.instance.configsApi.attachResourcePack
import com.magnariuk.util.instance.backupApi.backupInstance
import com.magnariuk.util.instance.checkInstance
import com.magnariuk.util.instance.createInstance
import com.magnariuk.util.instance.deleteInstance
import com.magnariuk.util.instance.editInstance
import com.magnariuk.util.instance.getInstance
import com.magnariuk.util.instance.launchServer
import com.magnariuk.util.instance.backupApi.listBackups
import com.magnariuk.util.instance.listInstances
import com.magnariuk.util.instance.openInstanceFolder
import com.magnariuk.util.instance.backupApi.rollbackInstance
import com.magnariuk.util.instance.configsApi.updateServerProperties
import com.magnariuk.util.uploadFile
import kotlinx.coroutines.runBlocking
import java.nio.file.Path

class MSo : CliktCommand() {
    init {
        completionOption()
        subcommands()
    }
    val def = INSTANCE_CONFIG()
    override val treatUnknownOptionsAsArgs = true
    val instance by option("-i", "--instance", help = "Name of The Instance")
    val version by option("-ver", "--version", help="Instance Version")
    val memory by option("-mem", "--memory", help="Memory allocation for the server (e.g., 1024M, 2G). Default is 2048M.")
    val loader by option("-load", "--loader", help="Instance loader. Default is vanilla")
    val loaderVersion by option("-lver", "--loader-version", help="Version of loader. Default is latest")
    val autoBackup: Boolean? by option("-ab", "--auto-backup")
        .convert { true }
    val noAutoBackup: Boolean? by option("-nab", "--no-auto-backup")
        .convert { false }
    val upload by option("-u","--upload", help="Upload the file to upload server.").flag()
    val resourcepack by option("-rp", "--resourcepack",
        help="Path or link to the resource pack .zip file to attach (for 'attach' and 'create' commands).")
    val resourcepackPort by option("-rpp", "--resourcepack-port", help="Port for the resource pack HTTP server (for 'attach', 'create', and 'edit' commands). Default is 2548.").int()
    val map: Map<String, String> by option("-m", "--map",
        help="Key and value for editing configs (not instances).").associate()
    val backup by option("-b", "--backup",
        help="Backup options for some commands.")
    val gui by option("-gui", "--gui",
        help="Reverses default option.").flag()
    private val command by option(
        "-c", "--command",
        help = "Command to execute: 'create', 'launch', 'check', 'edit', 'backup', " +
                "'delete', 'open', 'attach', 'list', 'edit-config', 'edit-sp', 'rollback', 'modrinth'."
    ).choice(
        "create",
        "launch",
        "check",
        "edit",
        "backup",
        "delete",
        "open",
        "attach",
        "list",
        "edit-config",
        "edit-sp",
        "rollback",
        "modrinth"
    ).required()
    val arguments by argument().multiple()

    val instanceCommands = setOf("create", "launch", "check", "edit", "backup", "delete", "open", "attach", "edit-sp", "rollback")

    val actions = mapOf<String, (List<String>) -> Unit>(
        "check" to { _ ->
            requireInstance { instance ->
                echo("Instance '$instance' exists.")
            }
        },
        "create" to { _ ->
            requireInstance (
                onInvalid = { instance ->
                    requireArguments(version, memory){ (ver, mem) ->
                        createInstance(
                            name = instance,
                            version = ver,
                            memory = mem,
                            autoBackup = autoBackup ?: def.autoBackup,
                            resourcePack = resourcepack ?: def.resourcepack,
                            resourcePackPort = resourcepackPort ?: def.resourcepackPort,
                            loader = loader ?: def.version.loader.type,
                            loaderVersion = loaderVersion ?: def.version.loader.version,
                        )
                    }
                }
            ) { instance ->
                echo("Instance '$instance' already exists.")
            }
        },
        "edit" to { _ ->
            requireInstance { instance ->
                val currentInstance = getInstance(instance)!!
                editInstance(
                    name = instance,
                    version = version ?: currentInstance.version.minecraft,
                    memory = memory ?: currentInstance.memory,
                    autoBackup = autoBackup ?: currentInstance.autoBackup,
                    resourcepack = resourcepack ?: currentInstance.resourcepack,
                    resourcepackPort = resourcepackPort ?: currentInstance.resourcepackPort,
                    backups = currentInstance.backups,
                    loaderType = loader ?: currentInstance.version.loader.type,
                    loaderVersion = loaderVersion ?: currentInstance.version.loader.version,
                )
            }
        },
        "list" to { _ ->
            withOptionalInstance(
                onInstance = { instance ->
                    listBackups(instance)
                },
                onNoInstance = { listInstances() }
            )
        },
        "launch" to { _ ->
            requireInstance { instance ->
                runBlocking { launchServer(instance, gui) }
            }
        },
        "backup" to { _ ->
            requireInstance { instance ->
                backupInstance(instance, backup ?: "")
            }
        },
        "rollback" to { _ ->
            requireInstance { instance ->
                requireArguments(backup) { (backup) ->
                    rollbackInstance(instance, backup)
                }
            }
        },
        "delete" to { _ ->
            requireInstance { instance ->
                deleteInstance(instance)
            }
        },
        "open" to { _ ->
            requireInstance { instance ->
                openInstanceFolder(instance)
            }
        },
        "attach" to { _ ->
            requireInstance { instance ->
                requireArguments(resourcepack) { (resourcepack) ->
                    var link = resourcepack
                    if(upload) {
                        try{
                            runBlocking {
                                link = uploadFile(Path.of(resourcepack))!! }
                        }catch(e: Exception){
                            echo("Failed to upload resourcepack '{args.resourcepack}': {e}. Trying to attach file.", err=true)
                            attachResourcePack(instance, resourcepack, resourcepackPort)
                        }
                    }else{
                        attachResourcePack(instance, resourcepack, resourcepackPort)
                    }
                }
            }
        },
        "edit-config" to { _ ->
            requireArguments(map){ (map) ->
                for (item in map) {
                    editGlobalConfig(item.key, item.value)
                }
            }
        },
        "edit-sp" to { _ ->
            requireInstance { instance ->
                requireArguments(map) { (map) ->
                    for (item in map) {
                        updateServerProperties(instance, item.key, item.value)
                    }
                }
            }
        },
        "modrinth" to { _ ->
            withOptionalInstance(
                onInstance = { instance ->},
                onNoInstance = {})
        }
    )

    fun withOptionalInstance(
        onInstance: (inst: String) -> Unit,
        onNoInstance: () -> Unit = {}
    ) {
        instance?.let { inst ->
            if (checkInstance(inst)) {
                onInstance(inst)
            } else {
                echo("Instance '$inst' does not exist", err = true)
            }
        } ?: onNoInstance()
    }
    fun <T> requireArguments(vararg args: T?, onValid: (List<T>) -> Unit) {
        val missing = args.withIndex().filter { it.value == null }.map { it.index }
        if (missing.isNotEmpty()) {
            echo("Missing required arguments at positions: ${missing.joinToString()}", err = true)
            return
        }
        onValid(args.filterNotNull())
    }




    fun requireInstance(
        onMissing: () -> Unit = { echo("This command requires an instance.", err = true) },
        onInvalid: (inst: String) -> Unit = { inst -> echo("Instance '$inst' does not exist", err = true) },
        onValid: (inst: String) -> Unit
    ) {
        instance?.let { inst ->
            if (!checkInstance(inst)) {
                onInvalid(inst)
            } else {
                onValid(inst)
            }
        } ?: onMissing()
    }

    override fun run() {
        actions[command]?.invoke(arguments)
            ?: echo("Command '$command' not implemented.", err = true)
    }


}



fun main(args: Array<String>) = MSo().main(args)